# The ANSI/VT100 terminals and terminal emulators can display colors
# and formatted text using escape sequences. Instead of using the raw
# ANSI escape sequences, we use the tput command which is ensures
# portability between various terminals and terminal emulators.

_tint_match_command() {
    local cmd=""
    local context=""
    case "$1" in
        bold)
            cmd="bold"
            context="bold"
            ;;
        dim)
            cmd="dim"
            context="dim"
            ;;
        underline)
            cmd="smul"
            context="underline"
            ;;
        standout)
            cmd="smso"
            context="standout"
            ;;
        blink)
            cmd="blink"
            context="blink"
            ;;
        invert)
            cmd="rev"
            context="invert"
            ;;
        hidden)
            cmd="invis"
            context="hidden"
            ;;
        reset)
            cmd="sgr0"
            context=""
            ;;
        black)
            cmd="setaf 0"
            context="fg"
            ;;
        red)
            cmd="setaf 1"
            context="fg"
            ;;
        green)

            cmd="setaf 2"
            context="fg"
            ;;
        yellow)
            cmd="setaf 3"
            context="fg"
            ;;
        blue)
            cmd="setaf 4"
            context="fg"
            ;;
        magenta)
            cmd="setaf 5"
            context="fg"
            ;;
        cyan)
            cmd="setaf 6"
            context="fg"
            ;;
        white)
            cmd="setaf 7"
            context="fg"
            ;;
        Black)
            cmd="setab 0"
            context="bg"
            ;;
        Red)
            cmd="setab 1"
            context="bg"
            ;;
        Green)
            cmd="setab 2"
            context="bg"
            ;;
        Yellow)
            cmd="setab 3"
            context="bg"
            ;;
        Blue)
            cmd="setab 4"
            context="bg"
            ;;
        Magenta)
            cmd="setab 5"
            context="bg"
            ;;
        Cyan)
            cmd="setab 6"
            context="bg"
            ;;
        White)
            cmd="setab 7"
            context="bg"
            ;;
        color*) 
            code=${1/color/}
            if [[ "$code" =~ ^[0-9]+$ ]]; then
                cmd="setaf $code"
                context="fg"
            fi
            ;;
        Color*) 
            code=${1/Color/}
            if [[ "$code" =~ ^[0-9]+$ ]]; then
                cmd="setab $code"
                context="bg"
            fi
            ;;
    esac

    printf "${cmd}:${context}"
}

_tint_parse() {
    local text="${1}"
    # passing assoc arrays as function arguments in bash is ... not pretty
    eval "declare -A context="${2#*=}

    local i char word cmd subject result content content_length content_suffix content_prefix
    word_char_regex="[a-zA-Z0-9]"
    word=""
    result=""
    for (( i=0; i<"${#text}"; i++ )); do
        char="${text:$i:1}"
        
        if [[ "$char" =~ $word_char_regex ]]; then
            word="${word}${char}"
        else 
            if [[ ! -z "$word" ]]; then
                if [[ "$char" == '(' ]]; then
                    IFS=':' read -r cmd context_name <<< "$(_tint_match_command "$word")"
                    if [[ ! -z "$cmd" ]] && [[ ! -z "$context_name" ]]; then

                        # if the current char is not a closing bracket that means that this is not 
                        # one of the tint functions, so we bail early
                        if [ "${text:$i:1}" != '(' ]; then
                            continue
                        fi
                        # otherwise we try to find the matching closing bracket
                        local counter=0
                        local ch prev_ch
                        local closing_bracket_position=
                        for (( j=$i; j<${#text}; j++ )); do
                            ch="${text:$j:1}"
                            if [[ "$ch" == '(' ]]; then
                                ((counter++))
                            elif [[ "$ch" == ')' ]] && [[ "$prev_ch" != '\' ]]; then
                                ((counter--))
                            fi
                            if [[ $counter -eq 0 ]]; then
                                closing_bracket_position=$j
                                break
                            fi
                            prev_ch="$ch"
                        done

                        if [[ ! -z "$closing_bracket_position" ]]; then
                            content_prefix="$(tput $cmd)"
                            # reset all settings
                            tputargs="sgr0" 
                            # and then set all the active contexts
                            for ctx in fg bg bold dim underline standout blink invert hidden; do
                                if [ ! -z "${context[$ctx]}" ]; then
                                    tputargs="${tputargs}\n${context[$ctx]}"
                                fi
                            done
                            content_suffix="$(printf "$tputargs" | tput -S)"
                            context_string=$(declare -p context)
                            eval "declare -A child_context="${context_string#*=}
                            child_context["$context_name"]="$cmd"
                            content_length=$(( closing_bracket_position-i-1 ))
                            content="${text:$((i+1)):$content_length}"
                            content="$(_tint_parse "$content" "$(declare -p child_context)")"
                            result="${result}${content_prefix}${content}${content_suffix}"
                            i=$closing_bracket_position
                        fi
                    fi
                    word=
                    char=
                fi
                result="${result}${word}${char}"
                word=""
            else
                result="${result}${char}"
                word=""
            fi
        fi
    done
    result="${result//\\(/(}"
    result="${result//\\)/)}"
    printf "${result}${word}"
}


tint_logo() {
    colors=(Red Green Yellow Magenta Blue Cyan)
    #colors=(Light_red Light_blue Light_yellow Light_cyan Light_magenta)
    regex="#"
    while IFS= read -r line; do
        while true; do
            if ! [[ "$line" =~ $regex ]]; then
                break;
            fi
            color="${colors[$RANDOM % ${#colors[@]}]}"
            line=${line/\#\#/$color(  )}
        done
        tint "$line"
    done < <(cat <<-'EOF'
	##########  ######  ####    ##  ##########
	    ##        ##    ##  ##  ##      ##    
	    ##        ##    ##    ####      ##    
	    ##      ######  ##      ##      ##    
	EOF
    )
}

tint_usage() {
    usage=$(cat <<"HELP_USAGE"

Usage: tint <string>

String format:                  String can  contain one or more tint functions.

Functions:                      Result:

  Effects:

    bold\(text)                   bold(text)
    underline\(text)              underline(text)
    invert\(text)                 invert(text)
    blink\(text)                  blink(text)
    hidden\(text)                 hidden(text)

  Foreground colors:

    black\(text)                  black(text)
    red\(text)                    red(text)
    green\(text)                  green(text)
    yellow\(text)                 yellow(text)
    blue\(text)                   blue(text)
    magenta\(text)                magenta(text)
    cyan\(text)                   cyan(text)
    white\(text)                  white(text)

  Background colors:

    Black\(text)                  Black(text)
    Red\(text)                    Red(text)
    Green\(text)                  Green(text)
    Yellow\(text)                 Yellow(text)
    Blue\(text)                   Blue(text)
    Magenta\(text)                Magenta(text)
    Cyan\(text)                   Cyan(text)
    White\(text)                  White(text)

Example:
    tint "white\(Cyan\(T)Magenta\(I)Yellow\(N)Black\(T)) is fun!"
Outputs:
    bold(Cyan(T)Magenta(I)Yellow(N)Black(T)) is fun!
    
HELP_USAGE
)
    tint "$usage"
}

tint() {
    if [ "$1" == "-n" ]; then
        shift
        tintf "$@"
    else
        tintf "$@"
        printf "\n"
    fi
}

tintf() {
    if [ "$1" == "-h" -o "$1" == "--help" ]; then
        tint_usage
        return
    fi

    if [ "$1" == "-l" -o "$1" == "--logo" ]; then
        tint_logo
        return
    fi

    # trailing newlines are removed with command substitution, to circumvent this, we add a trailing dot to the input string
    # and then remove the last character from the result string
    input="$1."
    shift

    # This is the initial context
    declare -A context
    context=( ["fg"]= ["bg"]= ["bold"]= ["dim"]= ["underline"]= ["standout"]= ["blink"]= ["invert"]= ["hidden"]= )
    result="$(_tint_parse "$(printf "$input" "${@}")" "$(declare -p context)")"
    printf "${result::-1}"
}
